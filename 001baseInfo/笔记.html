<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>


<div >
    <div id="box" title="模块化的进化过程">
            <div title="1.全局function模式：">
                *编码：全局变量/函数
                *问题：污染全局命名空间，容易引起命名冲突/数据不安全
            </div>
            <div title="2.namespace模式：">
                *编码：将数据/行为封装到对象中
                *解决：命名冲突（检索了全局变量）
                *问题：数据不安全（外包可以直接修改模块内部的数据）
            </div>
            <div title="3.IIFE模式/增强：">
                *IIFE：立即调用函数表达式-->你们函数自调用
                *编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口
                *引入依赖：通过函数形参来引入依赖模块
            </div>

    </div>
    <div id="box1" title="模块化规范-CommonJS">
        commonJS只是一个规范，通过export(s)的暴露和require的依赖

        <div title="1.Node.js：服务器端">
            *需要先安装node.js环境
        </div>
        1.在下方的Terminal窗口输入命令进入指定文件路径eg:cd e_commonJS01/commonjs
        2.创建package.json文件:npm init(默认可以先一路回车常见package.json文件。之后再进行修改)
        3.创建module.js和app.js文件。通过module.exports=value的方式暴露和require的方式引用进行简单演示
            在下方Terminal窗口打开到app.js文件的路径，然后输入node app进行启动
        4.启动方式2
            {
                "name": "commonjs",
                "version": "1.0.0",
                "description": "",
                "main": "module.js",
                "scripts": {
                "test": "echo \"Error: no test specified\" && exit 1"
                },
                "author": "",
                "license": "ISC"
            }
            package.json中的scripts里面的属性名可以修改，属性值即可以为执行的代码，如修改为
            {
                "name": "commonjs",
                "version": "1.0.0",
                "description": "",
                "main": "module.js",
                "scripts": {
                "start": " node app"
                },
                "author": "",
                "license": "ISC"
            }
            在下方Terminal窗口中输入npm start（npm xxx，xxx是scripts中的属性名）进行启动

        <div title="2.Browserify：浏览器端 也称为js的打包工具">
            <div title="定义暴露模块：exports">
                exports.xxx=value
                module.export=value
            </div>
            <div title="引入模块：require">
                var module=require('模块名/模块相对路径')
                *引入模块发生在什么时候？
                *Node:运行时，动态同步引入
                *Browserify：在运行前对模块进行编译/转译/打包的处理（已经将依赖的模块包含进来了）
                            运行的是打包生成的js，运行时不存在需要再从远程引入依赖模块
            </div>
        </div>
        require方法无法在浏览器端运行，只能在服务器端安装node.js运行
            比如：node app启动时可以获取到值
                 但在index.html引入app.js后运行时却报错“require未定义”




        <div title="3.IIFE模式/增强：">
            *IIFE：立即调用函数表达式-->你们函数自调用
            *编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口
            *引入依赖：通过函数形参来引入依赖模块
        </div>

    </div>

</div>
</body>
</html>